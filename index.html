<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Gamedev Canvas Workshop</title>
  <style>
    * {
      padding: 0;
      margin: 0;
    }

    canvas {
      background: #eee;
      display: block;
      margin: 0 auto;
    }

    p {
      position: absolute;
      top: 340px;
      left: 480px;
    }
  </style>
</head>

<body>

  <canvas id="myCanvas" width="480" height="320"></canvas>
  <p></p>


  <script>
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
    // Start ball at random locations on canvas
    var x = random(0, canvas.width);
    var y = random(0, canvas.height);
    // Set random initial direction
    // See http://stackoverflow.com/questions/8611830/javascript-random-positive-or-negative-number
    var dx = Math.round(Math.random()) * 2 - 1;
    var dy = Math.round(Math.random()) * 2 - 1;
    var ballRadius = 10;
    var paddleHeight = 10;
    var paddleWidth = 75;
    var paddleX = (canvas.width - paddleWidth) / 2;
    var rightPressed = false;
    var leftPressed = false;
    var ballColor = "0095DD";
    var para = document.querySelector("p");

    // To get a random floating point number within a certain range, first define the range by 'min' and 'max':
    // min + (Math.random() * (max - min))
    // See https://answers.yahoo.com/question/index?qid=20101101170531AA5KTeQ
    function random(min, max) {
      var num = Math.floor(Math.random() * (max - min)) + min;
      return num;
    }

    function drawBall(color) {
      ctx.beginPath();
      ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = color; // "#0095DD"
      ctx.fill();
      ctx.closePath();
    }

    function changeColor() {
      ballColor = 'rgb(' + random(0, 255) + ',' + random(0, 255) + ',' + random(0, 255) + ')';
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();
    }

    function increaseSpeed() {
      if (dx < 0) {
        dx -= 0.1; // increase horizontal speed left
      } else {
        dx += 0.1; // increase horizontal speed right
      }
      dy -= 0.1; // increase the vertical speed up
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // See https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect
      // The CanvasRenderingContext2D.clearRect() method of the Canvas 2D API sets all pixels in the rectangle defined by starting point (x, y) and size (width, height) to transparent black, erasing any previously drawn content.
      drawBall(ballColor);
      drawPaddle();

      if (x + dx < ballRadius || x + dx > canvas.width - ballRadius) { // Left || Right
        // If position of center of ball and the next change in horizontal movement is smaller than the radius of the ball, that means the ball has hit the left side of the canvas. This also means that the ball must have been moving leftwards, ie. dx is -2. Therefore now set dx to be positive and move it rightwards.
        dx = -dx;
        changeColor();
      }

      if (y + dy < ballRadius) { // Top
        // Likewise, if the position of the center of the ball and the change in vertical movement is greater than the height of canvas minus the ball radisu, it means that the ball has hit the bottom wall of the canvas, meaning it is moving downwards, ie. dy is positive. Therefore, now set dy to be negative and move it upwards.
        dy = -dy;
        changeColor();
      } else if (y + dy > canvas.height - ballRadius) { // Bottom
        if (x > paddleX && x < paddleX + paddleWidth) {
          // checks that the x-position of ball is within the length of the paddle, but it still hits the wall, not the paddle
          dy = -dy;
          increaseSpeed();
          para.innerHTML = "Horizontal speed dx is: " + dx + "<br>Vertical speed dy is now: " + dy;
        } else {
          alert("GAME OVER");
          document.location.reload();
        }
      }

      x += dx;
      y += dy;

      if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += 5; // random(5, 10)
      } else if (leftPressed && paddleX > 0) {
        paddleX -= 5;
      }
    }

    function keyDownHandler(e) {
      if (e.keyCode === 37) {
        leftPressed = true;
      } else if (e.keyCode === 39) {
        rightPressed = true;
      }
    }

    function keyUpHandler(e) {
      if (e.keyCode === 37) {
        leftPressed = false;
      } else if (e.keyCode === 39) {
        rightPressed = false;
      }
    }

    document.addEventListener("keydown", keyDownHandler, false); // target.addEventListener(type, listener[, useCapture]);
    document.addEventListener("keyup", keyUpHandler, false);
    // See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
    // useCapture Optional
    // A Boolean that indicates that events of this type will be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree. Events that are bubbling upward through the tree will not trigger a listener designated to use capture. Event bubbling and capturing are two ways of propagating events that occur in an element that is nested within another element, when both elements have registered a handle for that event. The event propagation mode determines the order in which elements receive the event. See DOM Level 3 Events and JavaScript Event order for a detailed explanation. If not specified, useCapture defaults to false.
    // Note: For event listeners attached to the event target; the event is in the target phase, rather than capturing and bubbling phases. Events in the target phase will trigger all listeners on an element regardless of the useCapture parameter.
    // Note: useCapture became optional only in more recent versions of the major browsers; for example, it was not optional before Firefox 6. You should provide this parameter for broadest compatibility.

    setInterval(draw, 10);
    // Or use window.requestAnimationFrame(); The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint.
  </script>

</body>

</html>
